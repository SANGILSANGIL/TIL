
![](http://wiki.geeekdev.com/lib/exe/fetch.php?cache=&w=525&h=700&tok=35377b&media=wiki:img_1039.jpg)

시스템 설계자는 프리페치 큐(다음 명령어의 큐 메모리)와 캐쉬 메모리(저장 메모리) 하위 시스템을 효율적으로 활용해서 
버스 경쟁 문제를 해결할수 있다. 위의 그림은 병렬로 연결된 버스를 나타내는 CPU내부의 모습이다. 

프리페치 큐는 명령어 스트림 데이터에 대한 버퍼로 사용할수 있다. 또 데이터 캐쉬외에 명령어 캐쉬를 추가해서 명령어를 
저장하는 버퍼로 이용할수 있다. 비록 프로그래머는 CPU의 캐쉬구성을 바꿀수는 없지만 특정한 CPU에서 명령어 캐쉬가 어떻게 
동작하는지를 이해 한다면 지연(CPU의 클럭 지연 및 파이프 라인 지연)을 피할수 있다.

CPU가 두개의 메모리 공간을 가지고 있다고 가정해 보자. 하나는 명령어를 위한 공간 / 다른 하나는 데이터를 위한 명령어 공간이다. 
이 두개는 각각의 버스를 가진다. 이 구조를 하버드 아키텍처라 한다. (당연히 하버드에서 만듬) 설계 초기엔 이 두개의 메모리 공간이
서로 분리되어 두개의 버스가 존재 하자 메모리 공간은 늘었지만 데이터 통신에 의한 지연으로 CPU가 더 느려지게 되었다. 
이를 해결하기 위해 두 메모리를 하나로 합치고 cPU에서 직접 접근 가능 하도록 만든 위의 이미지처럼 CPU로 발전하였다.

각 영역을 연결하는 경로는 각각의 버슬르 나타내는데 데이터는 이러한 모든 경로를 병력적으로 지나갈수 있다. 
이것은 프리페치 큐가 명령어 캐쉬에서 명령어op코드를 읽어오는 동안 실행 유닛이 데이터를 데이터 캐쉬에 쓸수 있따는 것을 의미 한다.
그러나 이렇게 캐쉬를 이용해도 버스 충돌문제는 일어 난다. 2개의 캐쉬가 있는 CPU구성에서도 명령어 캐쉬에 찾으려는 명령어가 
없을 때마다 BIU는 데이터/주소버스를 이용해서 메모리에서op코드를 읽어와 야 한다. 
마찬가지로 데이터 캐쉬도 계속해서 메모리에서 데이터를 읽어와서 저장한다.

길이가 짧은 명령어를 많이 사용할수록, 캐쉬에 더 많은 명령어가 들어 갈수록 버스 경쟁은 더 적게 발행한다. 
마찬가지로 임시 데이터를 레지스터에 저장하면, 데이터 캐쉬가 데이터를 메모리에서 읽어오거나 메모리에 다시 쓰는 작업을 하지 
않아도 되므로 부하를 줄일수 있다.
