#파이프 라이닝 - 여러 명령어 수행 중첩

![http://wiki.geeekdev.com/lib/exe/fetch.php?cache=&media=wiki:1.jpg](http://wiki.geeekdev.com/lib/exe/fetch.php?cache=&media=wiki:1.jpg)

일반적인 파이프 라인은 6단계를 거친다.

1. 메모리에서 명령어의 op코드를 읽어온다. 
2. op코드를 해석하고, 필요하면 변수 오퍼런드나 상수 오퍼런드를 미리 읽어 온다. 
3. 필요하면, 메모리 오퍼런드의 유효한 주소 값을 계산한다. 
4. 필요하면 메모리 오퍼런드나 레지스터의 값을 읽어온다. 
5. 연산을 수행한다. 
6. 연산 결과를 목적 레지스터에 저장한다.

네번째 단계에서 CPU가 소스 오퍼런드와 목적 오퍼런드의 값을 함께 읽어온다. 이것은 cpu에 여러개의 데이터 경로를 설치하고 
어떤 2개의 오퍼런드도 데이터 버스를 동시에 사용하지 않게 하면 가능하다.

각 단계마다 별개의 하드웨어를 설계하면, 대부분의 단계를 병력적으로 수행할수 있다. 물론 동시에 2개 이상의 명엉어의 op코드를 
읽어오고 해석할 수는 없다. 그러나 현재 명령어의 op코드를 해석하면서 다음 명령어의 op코드를 읽어올수는 있다. 

만약 n 단계의 파이프 라인이 있따면, 보통 n개의 명령어가 병력적으로 수행될 것이다.

![http://wiki.geeekdev.com/lib/exe/fetch.php?cache=&media=wiki:2.jpg](http://wiki.geeekdev.com/lib/exe/fetch.php?cache=&media=wiki:2.jpg)

CPU가 첫번쨰 명령어의 op코드를 읽어온다. 그리고 두번쨰에서는 첫번째 명령어의 op코드를 해석하기 시작하고, 첫번재 명령어가 
오퍼런드를 가지는 경우에 병렬적으로 한 블록의 바이트를 프리페치 큐에서 읽어온다. 이런 식으로 한단계식을 연속적으로 처리 
하는것이다.

하지만 여기서 지연은 생길수 있다. 각 실행단계에서의 수행시간이 지연되거나 (한 클럭이 넘어가거나) 메모리를 더 많이 참조하게
된다면 다음 수행은 지연 되게 된다.
